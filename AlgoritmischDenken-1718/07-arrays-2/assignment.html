<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Arrays 2</title>
    <script src="bundle.js"></script>
    <script src="student.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
    <style>
      #fallingBlocks {
        border-collapse: collapse;
        margin: 1em auto;
      }

      #fallingBlocks td {
        border: black solid 1px;
        padding: 5px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Arrays 2</h1>
      <div id="commands"></div>
      <span class="exercise-total-score"></span>
    </header>
    <aside>
      <div id="exercise-overview"></div>
      <div id="exercise-overview-collapser"><span>&#9658;</span></div>
    </aside>
    <div id="contents">
      <section class="interpretation exercise" data-exercise-name="rowSums">
        <header>
          <h1 class="exercise-header">Wat doet deze code?</h1>
        </header>
      </section>
      
      <section class="coding exercise" data-exercise-name="flatten" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">flatten(xss)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>flatten(xss)</code> die, gegeven
            een array van arrays, de elementen samenvoegt in een nieuwe array.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="pairs" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">pairs(xs)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>pairs(xs)</code> die gegeven een array
            alle opeenvolgende elementen groepeert in paren.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="longest" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">longest(xss)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>longest(xss)</code> die gegeven
            een array van arrays, de langste array opzoekt. Indien
            er meerdere langste arrays zijn, wordt de eerst voorkomende teruggegeven.
            Indien <code>xss</code> leeg is, wordt de lege array teruggegeven.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="orderedPairs" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">orderedPairs(xs)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>orderedPairs(xs)</code> die, gegeven de array <code>xs</code>,
            een lijst van alle koppels produceert waarvan de elementen deel uitmaken van <code>xs</code>.
          </p>
          <p>
            Bijvoorbeeld, voor <code>xs = [1, 2, 3]</code> moet de functie de lijst
            <code>[ [1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3] ]</code> teruggeven.
            De volgorde van de paren mag je vrij kiezen.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="unorderedPairs" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">unorderedPairs(xs)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>unorderedPairs(xs)</code> die, gegeven de array <code>xs</code>,
            een lijst van alle koppels $(x, y)$ produceert waarbij $x$ v&oacute;&oacute;r $y$
            voorkomt in <code>xs</code>.
          </p>
          <p>
            Bijvoorbeeld, voor <code>xs = [1, 2, 3]</code> moet de functie de lijst
            <code>[ [1, 2], [1, 3], [2, 3] ]</code> teruggeven.
            De volgorde van de paren mag je vrij kiezen.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="unorderedTriplets" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">unorderedTriplets(xs)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>unorderedTriplets(xs)</code> die, gegeven de array <code>xs</code>,
            een lijst van alle triplets $(x, y, z)$ produceert waarbij $x$ v&oacute;&oacute;r $y$ en $y$ v&oacute;&oacute;r $z$
            voorkomen in <code>xs</code>.
          </p>
          <p>
            Bijvoorbeeld, voor <code>xs = [1, 2, 3, 4]</code> moet de functie de lijst
            <code>[ [1, 2, 3], [1, 2, 4], [2, 3, 4] ]</code> teruggeven.
            De volgorde van de paren mag je vrij kiezen.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="pascal" data-exercise-difficulty="2">
        <header>
          <h1 class="exercise-header">pascal(n)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>pascal(n)</code> die de <code>n</code> eerste rijen van de
            driehoek van Pascal genereert. Deze wordt als volgt opgebouwd:
          </p>
          <ul>
            <li>
              De eerste rij bestaat uit &eacute;&eacute;n enkel element, namelijk <code>1</code>.
            </li>
            <li>
              Elke daarop volgende rij verkrijg je door koppels aangrenzende elementen uit de vorige rij
              met elkaar op te tellen, en de resulterende rij getallen aan beide kanten
              af te sluiten met een <code>1</code>. Bijvoorbeeld, stel dat de laatst opgebouwde rij
              <code>[1, 4, 6, 4, 1]</code> is. De volgende rij berekenen we
              door eerst de som van de koppels buren te nemen:
              <code>[1 + 4, 4 + 6, 6 + 4, 4 + 1]</code> of dus <code>[5, 10, 10, 5]</code>.
              We voegen vervolgens een <code>1</code> toe aan beide kanten:
              <code>[1, 5, 10, 10, 5, 1]</code>.
            </li>
          </ul>
          <p>
            Als we enkele rijen zo opbouwen krijgen we
            \[
              \begin{array}{c}
                1 \\
                1 \; 1 \\
                1 \; 2 \; 1 \\
                1 \; 3 \; 3 \; 1 \\
                1 \; 4 \; 6 \; 4 \; 1 \\
                1 \; 5 \; 10 \; 10 \; 5 \; 1 \\
              \end{array}
            \]
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="prefixes" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">prefixes(xs)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>prefixes(xs)</code> die, gegeven een array <code>xs</code>,
            alle prefixes van <code>xs</code> genereert. Een prefix van <code>xs</code> is een array
            waarvan de elementen gelijk zijn aan de eerste elementen van <code>xs</code>.
            Bijvoorbeeld, de prefixes van <code>[1, 2, 3]</code> zijn <code>[]</code>,
            <code>[1]</code>, <code>[1, 2]</code> en <code>[1,2,3]</code>.
          </p>
          <p>
            De prefixes moeten teruggegeven in een array, in stijgende lengte.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="zeroSumSubarrays" data-exercise-difficulty="2">
        <header>
          <h1 class="exercise-header">zeroSumSubarrays(ns)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>zeroSumSubarrays(ns)</code> die,
            gegeven een array getallen <code>ns</code>,
            alle deelarrays van <code>ns</code> opsomt waarvan de som gelijk is aan 0.
          </p>
          <p>
            Een deelarray van <code>ns</code> is een array waarvan de elementen
            aaneensluitend voorkomen in <code>ns</code>. Bijvoorbeeld,
            <code>[2, 3, 4]</code> is een deelarray van <code>[1, 2, 3, 4, 5]</code>,
            maar <code>[1, 3, 5]</code> niet.
          </p>
          <p>
            De volgorde waarin de deelarrays worden opgesomd maakt niets uit.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="width" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">width(matrix)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>width(matrix)</code> die, gegeven een matrix,
            het aantal kolommen in de matrix teruggeeft.
          </p>
          <p>
            De matrix is gegeven als een array van kolommen. Elke kolom bevat hetzelfde aantal elementen.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="height" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">height(matrix)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>height(matrix)</code> die, gegeven een matrix,
            het aantal rijen in de matrix teruggeeft.
          </p>
          <p>
            De matrix is gegeven als een array van kolommen. Elke kolom bevat hetzelfde aantal elementen.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="zeroMatrix" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">zeroMatrix(width, height)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>zeroMatrix(width, height)</code> die, gegeven twee positieve gehele getallen
            <code>width</code> en <code>height</code>, een matrix opbouwt met <code>height</code> rijen
            en <code>width</code> kolommmen, die gevuld zijn met <code>0</code>'en.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="identityMatrix" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">identityMatrix(width, height)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>identityMatrix(width, height)</code> die, gegeven twee positieve gehele getallen
            <code>width</code> en <code>height</code>, een matrix opbouwt met <code>height</code> rijen
            en <code>width</code> kolommmen. De matrix moet overal gevuld zijn met <code>0</code>'en, behalve
            op de hoofddiagonaal: deze moet <code>1</code>'tjes bevatten.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="fallingBlocks"
                                       data-exercise-difficulty="2">
        <header>
          <h1 class="exercise-header">fallingBlocks(grid)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>fallingBlocks(grid)</code> die, gegeven een matrix <code>0</code>'en en <code>1</code>'en,
            die respectievelijk lege en gevulde vakjes voorstellen, de matrix <code>grid</code> wijzigt door de blokjes te laten vallen.
          </p>
          <p>
            <code>grid[0][0]</code> stelt het vakje linksboven voor. Blokjes vallen dus door hun <code>y</code>-co&ouml;rdinaat te verhogen.
          </p>
          <table id="fallingBlocks">
            <tbody>
              <tr>
                <td>
                  <code>grid[0][0]</code>
                </td>
                <td>
                  <code>grid[1][0]</code>
                </td>
                <td>
                  <code>grid[2][0]</code>
                </td>                
              </tr>
              <tr>
                <td>
                  <code>grid[0][1]</code>
                </td>
                <td>
                  <code>grid[1][1]</code>
                </td>
                <td>
                  <code>grid[2][1]</code>
                </td>                
              </tr>
              <tr>
                <td>
                  <code>grid[0][2]</code>
                </td>
                <td>
                  <code>grid[1][2]</code>
                </td>
                <td>
                  <code>grid[2][2]</code>
                </td>                
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="transpose" data-exercise-difficulty="1">
        <header>
          <h1 class="exercise-header">transpose(grid)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>rotate(grid)</code> die, gegeven een matrix,
            de getransponeerde ervan uitrekent. Het resultaat moet als een nieuwe matrix teruggegeven worden.
          </p>
          <p>
            De getransponeerde van een matrix bekomt men door de kolommen te schrijven als rijen.
          </p>
        </div>
      </section>

      <section class="coding exercise" data-exercise-name="rotate" data-exercise-difficulty="2">
        <header>
          <h1 class="exercise-header">rotate(grid)</h1>
        </header>
        <div class="exercise-description">
          <p>
            Schrijf een functie <code>rotate(grid)</code> die, gegeven een matrix,
            de elementen 90&deg; draait in wijzerzin. Het resultaat moet als een nieuwe matrix teruggegeven worden.
          </p>
        </div>
      </section>
    </div>
  </body>
</html>
